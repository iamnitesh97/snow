//scripted rest
(function process(request, response) {
    var requestBody = JSON.parse(request.body.dataString);
    var location = requestBody.wireCenter;
    var workType = requestBody.workType;
    var searchWindowStart = requestBody.appointment.searchWindowStart;
    var searchWindowEnd = requestBody.appointment.searchWindowEnd;
    var latitude = requestBody.jobLocation.geoLocation.latitude;
    var longitude = requestBody.jobLocation.geoLocation.longitude;
    var street = requestBody.jobLocation.street;
    var city = requestBody.jobLocation.city;
    var state = requestBody.jobLocation.state;
    var country = requestBody.jobLocation.country;
    var zip = requestBody.jobLocation.zipCode;
    var day = requestBody.appointmentType;
    var startDate = new GlideDateTime(searchWindowStart.split('T')[0] + ' ' + searchWindowStart.split('T')[1]);
    var startDateNew = searchWindowStart.split('T')[0];
    var endDate = new GlideDateTime(searchWindowEnd.split('T')[0] + ' ' + searchWindowEnd.split('T')[1]);
    var availableAgents = [];
    var holidays = [];
    //check for duration not greater than 60days
    var diffMilliseconds = endDate.getNumericValue() - startDate.getNumericValue();
    var diffDays = Math.floor(diffMilliseconds / (1000 * 60 * 60 * 24));

    if (diffDays > 60) {
        var durationErrorMessage = "Duration should not be more than 60 days";
        response.setStatus(403);
        return durationErrorMessage;
    }
    //check for past date
    var todayDateTime = new GlideDateTime();

    if (startDate.compareTo(todayDateTime) < 0) {
        var pastErrorMessage = 'Appointment window should not be in the past';

        response.setStatus(403);
        return pastErrorMessage;
    }
    //date validation
    if (endDate <= startDate) {
        var dateValidationError = 'End date should be greater than start date';

        response.setStatus(403);
        return dateValidationError;
    }
    var territoryGR = new GlideRecord('sn_tp_territory');
    territoryGR.addQuery('name', location);
    territoryGR.query();

    if (territoryGR.next()) {
        var territorySysID = territoryGR.getValue('sys_id');

        var territoryMembershipGR = new GlideRecord('sn_tp_territory_membership_override');
        territoryMembershipGR.addQuery('territory', territorySysID);
        territoryMembershipGR.query();
        var territoryUser = false;

        while (territoryMembershipGR.next()) {
            territoryUser = true;
            var userSysID = territoryMembershipGR.getValue('user');

            var skillGR = new GlideRecord('cmn_skill');
            skillGR.addQuery('name', workType);
            skillGR.query();
            var skillFound = false;

            while (skillGR.next()) {
                var skillSysID = skillGR.getValue('sys_id');
                skillFound = true;

                var userSkillGR = new GlideRecord('sys_user_has_skill');
                userSkillGR.addQuery('skill', skillSysID);
                userSkillGR.addQuery('user', userSysID);
                userSkillGR.query();

                while (userSkillGR.next()) {
                    var agentSysID = userSkillGR.getValue('user');

                    var workScheduleGR = new GlideRecord('agent_work_schedule');
                    workScheduleGR.addQuery('user', agentSysID);
                    workScheduleGR.query();

                    while (workScheduleGR.next()) {
                        var work = workScheduleGR.getDisplayValue('work_schedule');

                        var cmn = new GlideRecord('cmn_schedule');
                        cmn.addQuery('name', work);
                        cmn.query();

                        while (cmn.next()) {
                            var cmnsys = cmn.getValue('sys_id');

                            var span = new GlideRecord('cmn_schedule_span');
                            span.addQuery('schedule', cmnsys);
                            span.query();

                            if (span.next()) {
                                var et = span.getDisplayValue('end_date_time').split(' ')[1];
                                var st = span.getDisplayValue('start_date_time').split(' ')[1];

                                var fromDate = new GlideDateTime(workScheduleGR.getValue('from_date') + ' ' + st);
                                var toDate = new GlideDateTime(workScheduleGR.getValue('to_date') + ' ' + et);

                                if (startDate.compareTo(fromDate) >= 0 && endDate.compareTo(toDate) <= 0) {
                                    availableAgents.push(userSkillGR.getDisplayValue('user'));

                                    var personal = new GlideRecord('agent_events');
                                    personal.addQuery('user', agentSysID);
                                    personal.query();

                                    if (personal.next()) {
                                        var personalSchedule = personal.getDisplayValue('personal_schedule');
                                        var pscheduleCheck = new GlideRecord('cmn_schedule');
                                        pscheduleCheck.addQuery('name', personalSchedule);
                                        pscheduleCheck.query();

                                        if (pscheduleCheck.next()) {
                                            var psysid = pscheduleCheck.getValue('sys_id');

                                            var getHoliday = new GlideRecord('cmn_schedule_span');
                                            getHoliday.addQuery('schedule', psysid);
                                            getHoliday.query();

                                            while (getHoliday.next()) {
                                                var endHolidayDate = new GlideDateTime(getHoliday.getDisplayValue('end_date_time'));
                                                var startHolidayDate = new GlideDateTime(getHoliday.getDisplayValue('start_date_time'));

                                                if (startHolidayDate.compareTo(startDate) <= 0 && endHolidayDate.compareTo(endDate) >= 0) {
                                                    var userIndex = availableAgents.indexOf(userSkillGR.getDisplayValue('user'));

                                                    if (userIndex !== -1) {
                                                        availableAgents.splice(userIndex, 1);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    var agentErr = 'No agent not found with this schedule in ServiceNow';

                                    response.setStatus(403);
                                    return agentErr;
                                }

                            }
                        }
                    }
                }
            }

            if (!skillFound) {
                var skillErr = 'No agents found with this skill in ServiceNow';
                response.setStatus(403);
                return skillErr;
            }
        }

        if (!territoryUser) {
            var territoryUserErr = 'No agents found with this Territory in ServiceNow';
            response.setStatus(403);
            return territoryUserErr;
        }
    } else {
        var territoryErr = 'No territory found in ServiceNow';
        response.setStatus(403);
        return territoryErr;
    }
    // 	if (holidays.length > 0) {
    //         var holidaysLine = holidays.join(', ');

    //     }
    if (availableAgents.length > 0) {
        var agentsLine = availableAgents.join(', ');
        gs.info('Available agents on schedule: ' + agentsLine);
    } else {
        gs.info('No agents available on schedule');
    }

    var appointmentScript = new sn_apptmnt_booking.appointmentApiUtil();
    var getlocation = street + ',' + city + ',' + state + ',' + country + '' + zip;
    //appointmentScript.getAddress(latitude, longitude);

    var availableAppointments = appointmentScript.getAvailableAppointments(getlocation, startDate, endDate, agentsLine, day); //holidays, startDateNew);

    if (
        !availableAppointments.result ||
        availableAppointments.result.length === 0 ||
        !availableAppointments.result[0].slots ||
        availableAppointments.result[0].slots.length === 0
    ) {
        var appointmentErrorMessage =
            'No appointments available between ' + startDate + ' and ' + endDate;
        response.setStatus(403);
        return appointmentErrorMessage;
    } else {
        response.setContentType('application/json');
        var responseBody = {
            availableAppointments: availableAppointments,
        };
        response.setBody(responseBody);
    }
})(request, response);
//script include
var appointmentApiUtil = Class.create();
appointmentApiUtil.prototype = {
        initialize: function() {},
   getAvailableAppointments: function(location, startDate, endDate, agentsLine, day) {
        var grServiceConfig = new GlideRecord('sn_apptmnt_booking_service_config');
        grServiceConfig.addQuery('active', true);
        grServiceConfig.addQuery('name', day);
        grServiceConfig.query();

        if (grServiceConfig.next()) {
            var dailyStartTime = grServiceConfig.getValue('daily_start_time');
            var dailyEndTime = grServiceConfig.getValue('daily_end_time');
            var appointmentDuration = grServiceConfig.getValue('appointment_duration') * 60;
            var bookableDays = grServiceConfig.getValue('bookable_days');

            var formatStart = dailyStartTime + ':00';
            var formatEnd = dailyEndTime + ':00';

            var appointmentList = [];
            var anyAppointmentsFound = false;

            var currentDate = new GlideDateTime(startDate);
            var timezoneOffset = currentDate.getTZOffset();

            while (currentDate.compareTo(new GlideDateTime(endDate)) <= 0) {
                var currentDayOfWeek = currentDate.getDayOfWeekUTC().toString();

                // Check if the current day is a bookable day
                if (bookableDays.includes(currentDayOfWeek)) {
                    var startDateTime = new GlideDateTime(currentDate.getValue());
                    startDateTime.setDisplayValue(currentDate.getValue().split(' ')[0] + ' ' + formatStart);
                    var endDateTime = new GlideDateTime(currentDate.getValue());
                    endDateTime.setDisplayValue(currentDate.getValue().split(' ')[0] + ' ' + formatEnd);

                    var currentDateTime = new GlideDateTime(startDateTime);
                    var availableAppointments = [];
                    var todayDateTime = new GlideDateTime();

                    // if (startDateTime.compareTo(todayDateTime) < 0) {
                    //     var errorMessage = 'Appointment window should not be in the past';
                    //     var errorObject = {
                    //         message: errorMessage,
                    //         status: 403
                    //     };
                    //     response.setStatus(403);
                    //     return errorObject;
                    // }

                    while (currentDateTime.compareTo(endDateTime) <= 0) {
                        var currentStartTime = currentDateTime.getDisplayValue().split(' ')[1]; // Extract only the time portion
                        var currentEndTime = new GlideDateTime(currentDateTime);
                        currentEndTime.addSeconds(appointmentDuration);
                        var formattedCurrentEndTime = currentEndTime.getDisplayValue().split(' ')[1]; // Extract only the time portion

                        if (currentEndTime.compareTo(endDateTime) <= 0) { // Check if the current end time is less than or equal to the end time
                            var appointment = {
                                startTime: currentDate.getValue().split(' ')[0] + ' ' + currentStartTime,
                                endTime: currentDate.getValue().split(' ')[0] + ' ' + formattedCurrentEndTime,
                                duration: grServiceConfig.getValue('appointment_duration') + ' minutes'
                            };

                            availableAppointments.push(appointment);
                        }

                        currentDateTime.addSeconds(appointmentDuration);
                    }

                    var grAppointment = new GlideRecord('sn_apptmnt_booking_appointment_booking');
                    grAppointment.addQuery('start', '>=', startDateTime);
                    grAppointment.addQuery('end', '<=', endDateTime);
                    grAppointment.query();

                    var bookedAppointments = [];

                    while (grAppointment.next()) {
                        var appointmentStart = grAppointment.start.getDisplayValue();
                        var appointmentEnd = grAppointment.end.getDisplayValue();

                        for (var i = availableAppointments.length - 1; i >= 0; i--) {
                            var slotStart = availableAppointments[i].startTime;
                            var slotEnd = availableAppointments[i].endTime;

                            if (slotStart === appointmentStart && slotEnd === appointmentEnd) {
                                availableAppointments.splice(i, 1);
                                break;
                            }
                        }

                        bookedAppointments.push(appointmentStart + '-' + appointmentEnd);
                    }

                    if (availableAppointments && availableAppointments.length > 0) {
                        appointmentList.push({
                            date: 'Available Appointment Slots on ' + currentDate.getValue().split(' ')[0],
                            appointmentType: day,
                            newdate: ' ' + currentDate.getValue().split(' ')[0],
                            location: location,
                            agent: agentsLine,
                            // Add the location address to the response
                            slots: availableAppointments.filter(function(slot) {
                                var appointmentSlot = slot.startTime + '-' + slot.endTime;
                                return (
                                    bookedAppointments.indexOf(appointmentSlot) === -1 &&
                                    slot.startTime >= startDate &&
                                    slot.endTime <= endDate
                                );
                            })
                        });
                        anyAppointmentsFound = true;
                    } else {
                        // No available slots on the current date
                        var errorMessage = 'No available slots on ' + currentDate.getValue().split(' ')[0];
                        // var errorObject = {
                        //     message: errorMessage,
                        //     status: 403
                        // };
                        // response.setStatus(403);
                        // return errorObject;

                    }
                }

                currentDate.addDaysLocalTime(1); // Increment the date for the next iteration
            }
            if (!anyAppointmentsFound) {
                // No appointments available between the specified start and end dates
                var errorMessagee = 'No appointments available between ' + startDate + ' and ' + endDate;
                var errorObjecte = {
                    message: errorMessagee,
                    status: 403
                };
                response.setStatus(403);
                return errorObjecte;
            }

            //         if (appointmentList.length === 0) {
            //       var errorMessagee = 'No appointments available between ' + startDate + ' and ' + endDate;
            //       var errorObjecta = {
            //           message: errorMessagee,
            //           status: 403
            //       };
            //       response.setStatus(403);
            //       return errorObjecta;
            //   }
            var formattedResponse = {
                result: appointmentList.map(function(appointment) {
                    return {
                        date: appointment.date,
                        appointmentType: appointment.appointmentType,
                       // agents: appointment.agent,
                        location: appointment.location,
                        availableAgents: agentsLine,
                        // Include the location address in the response
                        slots: appointment.slots.map(function(slot) {
                            return 'StartDateTime: ' + slot.startTime + ', EndDateTime: ' + slot.endTime;
                        })
                    };
                })
            };
            return formattedResponse;
        } else {
            var errAppointment = 'No appointment found in the system';
            response.setStatus(400);
            return {
                error: {
                    message: errAppointment
                }
            };
        }
    },


                    type: 'appointmentApiUtil'
                };
